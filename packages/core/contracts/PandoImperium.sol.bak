pragma solidity ^0.4.18;

import "./PandoApp.sol";


// DEFINIR UNE INTERFACE SUR COMMENT ON GERE LES REQUETES PANDO

contract PandoImperium is IPandoRequestHandler, PandoApp {
    using SafeMath for uint256;

    MiniMeToken     token;
    PandoRepository repository;

    mapping(bytes32 => mapping(address => uint256)) values;


    struct HandleRequest {
        PandoBranch branch;
        uint256     pushId;
    }
    // We need to allow update on Request: so basically when we do require change we do cancel a branchrequestid, create a new requestid and upadte the id in the request struct.

    HandleRequest[] internal handleRequests; // first index is 1

    bytes32 constant public PROCESS_REQUEST_ROLE = keccak256("VALUATE_REQUEST_ROLE");
    bytes32 constant public EXECUTE_REQUEST_ROLE = keccak256("EXECUTE_REQUEST_ROLE");

    event Valuate(bytes32 hash, address branch, uint256 value);
    event ExecuteRequest();

    function initialize(MiniMeToken _token) onlyInit external {
        initialized();
        token = _token;
    }

    function valueOf(bytes32 _hash, address _branch) view returns (uint256) {

    }


    function forward(bytes _evmScript) public {
        require(canForward(msg.sender, _evmScript));
        // extract branch address and ForwardRequestId

        PandoBranch branch;
        uint256


        _newHandleRequest(_evmScript, "");
    }


    function update

    function handleRequest(uint256 _requestId, Branch _branch, uint256 _value, bool _accepted) auth(VALUATE_ROLE) external {
      _valuate(_hash, _branch, _value);
    }


    function handleRequest(uint256 _requestId, Branch)

    function _processRequest(bytes32 _hash, address _branch, uint256 _value) internal {
      values[_hash][_branch] = _value;
      Valuate(_hash, _branch, _value);
    }

    function executeRequest(uint256 _voteId) isInitialized external {
        /* require(canExecute(_voteId)); */
        _executeRequest(_voteId);
    }

    function _handleRequest(uint256 _requestId) internal {
        Request storage request = requests[_requestId];
        Branch  memory  branch  = request.branch;
        uint256 pushId          = request.pushId;


        branch.merge(pushId);

        Request storage vote = votes[_voteId];
        uint256 scriptLength = 64; // 4 (spec) + 20 (address) + 4 (calldataLength) +  32 (input) + 4 (padding from 60 to 64)
        uint256 value       = vote.totalValue.div(vote.totalWeight);
        bytes memory script = new bytes(scriptLength);

        vote.executed = true;
        executionScript = vote.executionScript;

        assembly {
            mstore(add(executionScript, 0x40), value)
        }

        runScript(executionScript, new bytes(0), new address[](0));

        ExecuteRequest(_requestId);
    }
}
