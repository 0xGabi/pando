const sha3 = require('solidity-sha3').default

const { assertRevert } = require('@aragon/test-helpers/assertThrow')

const getBlockNumber = require('@aragon/test-helpers/blockNumber')(web3)

const DAOFactory = artifacts.require('@aragon/os/contracts/factory/DAOFactory')
const EVMScriptRegistryFactory = artifacts.require('@aragon/os/contracts/factory/EVMScriptRegistryFactory')
const ACL = artifacts.require('@aragon/os/contracts/acl/ACL')
const Kernel = artifacts.require('@aragon/os/contracts/kernel/Kernel')
const Specimen = artifacts.require('Specimen')
const Branch = artifacts.require('Branch')
// const SpecimenKit = artifacts.require('SpecimenKit')
const TokenManager = artifacts.require('@aragon/apps-token-manager/contracts/TokenManager')
const MiniMeToken = artifacts.require('@aragon/os/contracts/lib/minime/MiniMeToken')

const ANY_ADDR = '0xffffffffffffffffffffffffffffffffffffffff'
const NULL_ADDR = '0x0000000000000000000000000000000000000000'

const hash_1 = '0x11111111111111111111111111111111'
const hash_2 = '0x22222222222222222222222222222222'

const submittedRequestId = receipt => receipt.logs.filter(x => x.event == 'SubmitRequest')[0].args.requestId
const createdBranchId = receipt => receipt.logs.filter(x => x.event == 'CreateBranch')[0].args.branchId

const handledRequestCommitId = receipt => {
    if (receipt.logs.filter(x => x.event == 'NewCommit')[0]) {
        return receipt.logs.filter(x => x.event == 'NewCommit')[0].args.commitId
    } else {
        return undefined
    }
}

const REQUEST_STATUS = ['OPEN', 'MERGED', 'REJECTED', 'CANCELLED'].reduce((state, key, index) => {
    state[key] = index
    return state
}, {})

const REQUEST_STATE = ['PENDING', 'VALUATED', 'HANDLED'].reduce((state, key, index) => {
    state[key] = index
    return state
}, {})

const REQUEST_ACTION = ['MERGE', 'REJECT', 'CANCEL'].reduce((state, key, index) => {
    state[key] = index
    return state
}, {})

contract('Specimen App', accounts => {
    let factory, token, tokenManager, dao, acl, specimen, master

    const root = accounts[0]
    const author = accounts[1]
    const origin = accounts[2]
    const authorized = accounts[3]
    const unauthorized = accounts[4]
    const parents = web3.eth.abi.encodeParameters(['address', 'bytes32', 'address', 'bytes32'], [authorized, hash_1, author, hash_2])

    const deploy = async () => {
        // MiniMeToken
        const token = await MiniMeToken.new(NULL_ADDR, NULL_ADDR, 0, 'Native Governance Token', 0, 'NGT', false)
        // DAO
        const receipt_1 = await factory.newDAO(root)
        const dao = await Kernel.at(receipt_1.logs.filter(l => l.event == 'DeployDAO')[0].args.dao)
        const acl = await ACL.at(await dao.acl())
        await acl.createPermission(root, dao.address, await dao.APP_MANAGER_ROLE(), root, { from: root })
        // TokenManager
        const receipt_2 = await dao.newAppInstance('0x0001', (await TokenManager.new()).address, { from: root })
        const tokenManager = await TokenManager.at(receipt_2.logs.filter(l => l.event == 'NewAppProxy')[0].args.proxy)
        await acl.createPermission(root, tokenManager.address, await tokenManager.MINT_ROLE(), root, { from: root })
        await acl.createPermission(root, tokenManager.address, await tokenManager.ISSUE_ROLE(), root, { from: root })
        await acl.createPermission(root, tokenManager.address, await tokenManager.ASSIGN_ROLE(), root, { from: root })
        await acl.createPermission(root, tokenManager.address, await tokenManager.REVOKE_VESTINGS_ROLE(), root, { from: root })
        await acl.createPermission(root, tokenManager.address, await tokenManager.BURN_ROLE(), root, { from: root })
        await token.changeController(tokenManager.address)
        await tokenManager.initialize(token.address, false, 0, false)
        // Specimen
        const receipt_3 = await dao.newAppInstance('0x0002', (await Specimen.new()).address, { from: root })
        const specimen = await Specimen.at(receipt_3.logs.filter(l => l.event == 'NewAppProxy')[0].args.proxy)
        await acl.createPermission(authorized, specimen.address, await specimen.CREATE_BRANCH_ROLE(), root, { from: root })
        await acl.createPermission(authorized, specimen.address, await specimen.FREEZE_BRANCH_ROLE(), root, { from: root })
        await acl.createPermission(authorized, specimen.address, await specimen.ISSUE_REWARD_ROLE(), specimen.address, { from: root })
        await specimen.initialize(tokenManager.address)
        await acl.grantPermission(specimen.address, dao.address, await dao.APP_MANAGER_ROLE(), { from: root })
        await acl.grantPermission(specimen.address, tokenManager.address, await tokenManager.MINT_ROLE(), { from: root })
        // Master branch
        // const receipt_4 = await specimen.createBranch('master', { from: root })
        // const master = await Branch.at(receipt_4.logs.filter(l => l.event == 'CreateBranch')[0].args.proxy)
        // await acl.createPermission(authorized, master.address, await master.SUBMIT_REQUEST_ROLE(), root, { from: root })
        // await acl.createPermission(authorized, master.address, await master.VALUATE_REQUEST_ROLE(), root, { from: root })
        // await acl.createPermission(authorized, master.address, await master.HANDLE_REQUEST_ROLE(), root, { from: root })

        return { token, tokenManager, dao, acl, specimen }
    }

    before(async () => {
        const kernelBase = await Kernel.new()
        const aclBase = await ACL.new()
        const regFact = await EVMScriptRegistryFactory.new()
        factory = await DAOFactory.new(kernelBase.address, aclBase.address, regFact.address)
    })

    beforeEach(async () => {
        ;({ token, tokenManager, dao, acl, specimen } = await deploy())
    })

    context('#initialize', () => {
        it('should set token manager properly', async () => {
            const manager = await specimen.tokenManager()
            assert.equal(manager, tokenManager.address)
        })

        it('should revert on reinitialization', async () => {
            return assertRevert(async () => {
                await specimen.initialize(tokenManager.address, { from: root })
            })
        })
    })

    context('#createBranch', () => {
        it("should succeed to create branch if address is granted 'CREATE_BRANCH_ROLE'", async () => {
            const ISSUE_REWARD_ROLE = await specimen.ISSUE_REWARD_ROLE()

            const receipt = await specimen.createBranch('master', { from: authorized })
            const master = await Branch.at(receipt.logs.filter(l => l.event == 'CreateBranch')[0].args.proxy)

            const spec = await master.specimen()
            const name = await master.name()
            const role = await acl.hasPermission(master.address, specimen.address, ISSUE_REWARD_ROLE)

            assert.equal(spec, specimen.address)
            assert.equal(name, 'master')
            assert.equal(role, true)
        })

        it("should fail to create branch if address is not granted 'CREATE_BRANCH_ROLE'", async () => {
            return assertRevert(async () => {
                await specimen.createBranch('dev', { from: unauthorized })
            })
        })
    })

    context('#issueReward', () => {
        it("should succeed to issue reward if address is granted 'ISSUE_REWARD_ROLE'", async () => {
            await specimen.issueReward(origin, 100, { from: authorized })
            const balance = await token.balanceOf(origin)

            assert.equal(balance, 100)
        })

        it("should fail to issue reward if address is not granted 'ISSUE_REWARD_ROLE'", async () => {
            return assertRevert(async () => {
                await await specimen.issueReward(origin, 100, { from: unauthorized })
            })
        })

        it('should automatically be called when a request for commit is merged', async () => {
            const receipt = await specimen.createBranch('master', { from: authorized })
            const master = await Branch.at(receipt.logs.filter(l => l.event == 'CreateBranch')[0].args.proxy)

            await acl.createPermission(ANY_ADDR, master.address, await master.SUBMIT_REQUEST_ROLE(), root, { from: root })
            await acl.createPermission(authorized, master.address, await master.VALUATE_REQUEST_ROLE(), root, { from: root })
            await acl.createPermission(authorized, master.address, await master.HANDLE_REQUEST_ROLE(), root, { from: root })

            const requestId = submittedRequestId(await master.submitRequest('awesomeIpfsHash', 'First commit', parents, { from: origin }))

            await master.valuateRequest(requestId, 100, { from: authorized })
            await master.handleRequest(requestId, REQUEST_ACTION.MERGE, { from: authorized })

            const balance = await token.balanceOf(origin)

            assert.equal(balance, 100)
        })
    })

    context('#getBranch', () => {
        it("should return branch's proxy address", async () => {
            const receipt = await specimen.createBranch('master', { from: authorized })
            const branchId = createdBranchId(receipt)
            const proxy = receipt.logs.filter(l => l.event == 'CreateBranch')[0].args.proxy

            assert.equal(await specimen.getBranch(branchId), proxy)
        })
    })

    context('#getBranches', () => {
        it('should return branches proxies addresses', async () => {
            const receipt_1 = await specimen.createBranch('master', { from: authorized })
            const receipt_2 = await specimen.createBranch('dev', { from: authorized })
            const receipt_3 = await specimen.createBranch('alternative', { from: authorized })

            const proxy_1 = receipt_1.logs.filter(l => l.event == 'CreateBranch')[0].args.proxy
            const proxy_2 = receipt_2.logs.filter(l => l.event == 'CreateBranch')[0].args.proxy
            const proxy_3 = receipt_3.logs.filter(l => l.event == 'CreateBranch')[0].args.proxy

            const proxies = await specimen.getBranches()

            assert.equal(proxies[0], proxy_1)
            assert.equal(proxies[1], proxy_2)
            assert.equal(proxies[2], proxy_3)
        })
    })
})
