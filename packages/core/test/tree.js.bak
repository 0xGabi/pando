const namehash = require('eth-ens-namehash').hash
const keccak256 = require('js-sha3').keccak256
const artifactor = require('truffle-contract')

const Kernel = artifactor(require('@aragon/os/build/contracts/Kernel.json'))
const DAOFactory = contract(
  require('@aragon/os/build/contracts/DAOFactory.json')
)
const ACL = artifactor(require('@aragon/os/build/contracts/ACL.json'))
const AppProxy = artifactor(
  require('@aragon/os/build/contracts/AppProxyUpgradeable.json')
)

const Tree = artifacts.require('./Tree.sol')

const GAS = 0xfffffffffff
const APP_BASE_NAMESPACE = '0x' + keccak256('base')
const APP_ID = namehash('pando.aragonpm.test')

// const kernelBase = await this.repository.pando.contracts.kernel.new()
// const aclBase = await this.repository.pando.contracts.acl.new()
// const factory = await this.repository.pando.contracts.daoFactory.new(
//   kernelBase.address,
//   aclBase.address,
//   '0x00'
// )
// const appProxyFactory = await this.repository.pando.contracts.appProxyFactory.new()
//
// // Deploy aragonOS-based DAO
// const receipt = await factory.newDAO(this.repository.config.author.account)
// const kernelAddress = receipt.logs.filter(l => l.event === 'DeployDAO')[0]
//   .args.dao
// const kernel = await this.repository.pando.contracts.kernel.at(
//   kernelAddress
// )
// const acl = await this.repository.pando.contracts.acl.at(await kernel.acl())
// // Grant current author APP_MANAGER_ROLE over the DAO
// const APP_MANAGER_ROLE = await kernel.APP_MANAGER_ROLE()
// const receipt2 = await acl.createPermission(
//   this.repository.config.author.account,
//   kernel.address,
//   APP_MANAGER_ROLE,
//   this.repository.config.author.account
// )
// // // Deploy tree app
// const APP_BASE_NAMESPACE = await kernel.APP_BASES_NAMESPACE()
// const APP_NAMESPACE = await kernel.APP_ADDR_NAMESPACE()
//
// let tree = await this.repository.pando.contracts.tree.new()
//
// // const receipt3 = await kernel.newAppInstance(
// //   Remote.TREE_BASE_APP_ID,
// //   tree.address
// // )
//
// // await kernel.setApp(
// //   APP_BASE_NAMESPACE,
// //   Remote.TREE_BASE_APP_ID,
// //   tree.address
// // )
//
// await kernel.setApp(
//   Remote.APP_BASE_NAMESPACE,
//   Remote.TREE_BASE_APP_ID,
//   tree.address
// )
//
// const initializationPayload = tree.contract.initialize.getData()
//
// // const appProxy = await this.repository.pando.contracts.appProxyUpgradeable.new(
// //   kernel.address,
// //   Remote.TREE_BASE_APP_ID
// // )
//
// const appProxy = await this.repository.pando.contracts.appProxyUpgradeable.new(
//   kernel.address,
//   Remote.TREE_BASE_APP_ID,
//   initializationPayload,
//   { gas: 6e6 }
// )
//
// let address = appProxy.address
//
// await kernel.setApp(
//   APP_NAMESPACE,
//   Remote.TREE_BASE_APP_ID,
//   appProxy.address
// )
//
// // const appProxy = await appProxyFactory.newAppProxy(
// //   kernel.address,
// //   Remote.TREE_BASE_APP_ID,
// //   initializationPayload
// // )
// //
// // const address = appProxy.logs.filter(l => l.event === 'NewAppProxy')[0].args
// //   .proxy
//
// tree = await this.repository.pando.contracts.tree.at(address)
//
// // await kernel.setApp(
// //   Remote.APP_BASE_NAMESPACE,
// //   Remote.TREE_BASE_APP_ID,
// //   appProxy.address
// // )
//
// // // Create PUSH role
// const PUSH = await tree.PUSH()
//
// const receipt4 = await acl.createPermission(
//   this.repository.config.author.account,
//   tree.address,
//   PUSH,
//   this.repository.config.author.account
// )
// // // Save remote's address
// this.saveAddress(name, kernel.address)
// // // Create remote object
// const remote = new Remote(this.repository, kernel, acl, tree, name)
// // // Create remote master branch
// const master = await remote.branches.create('master')
//
// return remote

contract('Tree', accounts => {
  let kernel, acl, tree

  before(async () => {
    // Configure artifacts
    // Kernel.setProvider(web3.currentProvider)
    // Kernel.defaults({ from: accounts[0], gas: GAS })
    // DAOFactory.setProvider(web3.currentProvider)
    // DAOFactory.defaults({ from: accounts[0], gas: GAS })
    // ACL.setProvider(web3.currentProvider)
    // ACL.defaults({ from: accounts[0], gas: GAS })
    // AppProxy.setProvider(web3.currentProvider)
    // AppProxy.defaults({ from: accounts[0], gas: GAS })
    // Deploy DAOFactory
    // const kernelBase = await Kernel.new()
    // const aclBase = await ACL.new()
    // const factory = await DAOFactory.new(
    //   kernelBase.address,
    //   aclBase.address,
    //   '0x00'
    // )
    // Deploy aragonOS-based DAO
    // const receipt = await factory.newDAO(this.repository.config.author.account)
    // const dao = receipt.logs.filter(l => l.event === 'DeployDAO')[0].args.dao
    //
    // kernel = await Kernel.at(dao)
    // acl = await ACL.at(await kernel.acl())
    // // Grant current author APP_MANAGER_ROLE over the DAO
    // const APP_MANAGER_ROLE = await kernel.APP_MANAGER_ROLE()
    // const receipt2 = await acl.createPermission(
    //   this.repository.config.author.account,
    //   kernel.address,
    //   APP_MANAGER_ROLE,
    //   this.repository.config.author.account
    // )
    //   let receipt = await factory.newDAO(accounts[0])
    //   let address = receipt.logs.filter(l => l.event === 'DeployDAO')[0].args.dao
    //
    //   kernel = await Kernel.at(address)
    //   acl = await ACL.at(await kernel.acl())
    //
    //   // Grant accounts[0] APP_MANAGER_ROLE over the DAO
    //   let APP_MANAGER_ROLE = await kernel.APP_MANAGER_ROLE()
    //   let receipt2 = await acl.createPermission(
    //     accounts[0],
    //     kernel.address,
    //     APP_MANAGER_ROLE,
    //     accounts[0]
    //   )
  })
  //
  it('should deploy correctly', async () => {
    let base = await Specimen.new()
    let receipt = await kernel.newAppInstance(APP_ID, base.address)
    let address = receipt.logs.filter(l => l.event === 'NewAppProxy')[0].args
      .proxy
    specimen = await Specimen.at(address)
  })
  //
  // it('should create PUSH role correctly', async () => {
  //   const PUSH = await specimen.PUSH()
  //   let receipt = await acl.createPermission(
  //     accounts[0],
  //     specimen.address,
  //     PUSH,
  //     accounts[0]
  //   )
  // })
  //
  // it('should grant PUSH role correctly', async () => {
  //   const PUSH = await specimen.PUSH()
  //   let receipt = await acl.grantPermission(accounts[1], specimen.address, PUSH)
  // })
  //
  // it('should create new branch correctly', async () => {
  //   let receipt = await specimen.newBranch('testbranch')
  //   let logName = receipt.logs.filter(l => l.event === 'NewBranch')[0].args.name
  //   let branchName = await specimen.branches(0)
  //
  //   assert.equal(
  //     branchName,
  //     'testbranch',
  //     'the registered branch name is incorrect'
  //   )
  //   assert.equal(
  //     logName,
  //     'testbranch',
  //     'the event broadcasted branch name is incorrect'
  //   )
  // })
  //
  // it('should push snapshots correctly', async () => {
  //   let receipt = await specimen.setHead('testbranch', 'Qmv85')
  //   // event NewSnapshot(string branch, address author, string cid);
  //   let branch = receipt.logs.filter(l => l.event === 'NewSnapshot')[0].args
  //     .branch
  //   let author = receipt.logs.filter(l => l.event === 'NewSnapshot')[0].args
  //     .author
  //   let cid = receipt.logs.filter(l => l.event === 'NewSnapshot')[0].args.cid
  //
  //   let branchReg = await specimen.branches(0)
  //
  //   let hash = '0x' + keccak256('testbranch')
  //   let head = await specimen.getHead(hash)
  //
  //   console.log(branch)
  //   console.log(author)
  //   console.log(cid)
  //   console.log(branchReg)
  //   console.log(head)
  //
  //   // let hash = '0x' + keccak256('testbranch')
  //   // let headH = await specimen.getHeadH(hash);
  //   // console.log(headH)
  //
  //   // let branchName = await specimen.branches(0)
  //   //
  //   // assert.equal(branchName, 'testbranch', 'the registered branch name is incorrect')
  //   // assert.equal(logName, 'testbranch', 'the event broadcasted branch name is incorrect')
  // })
  //
  // it('should fail if not push RIGHTS', async () => {
  //   let receipt = await specimen.setHead('testbranch', 'Qmv85', {
  //     from: accounts[2]
  //   })
  //   // event NewSnapshot(string branch, address author, string cid);
  //   let branch = receipt.logs.filter(l => l.event === 'NewSnapshot')[0].args
  //     .branch
  //   let author = receipt.logs.filter(l => l.event === 'NewSnapshot')[0].args
  //     .author
  //   let cid = receipt.logs.filter(l => l.event === 'NewSnapshot')[0].args.cid
  //
  //   let branchReg = await specimen.branches(0)
  //
  //   let hash = '0x' + keccak256('testbranch')
  //   let head = await specimen.getHead(hash)
  //
  //   console.log(branch)
  //   console.log(author)
  //   console.log(cid)
  //   console.log(branchReg)
  //   console.log(head)
  //
  //   // let hash = '0x' + keccak256('testbranch')
  //   // let headH = await specimen.getHeadH(hash);
  //   // console.log(headH)
  //
  //   // let branchName = await specimen.branches(0)
  //   //
  //   // assert.equal(branchName, 'testbranch', 'the registered branch name is incorrect')
  //   // assert.equal(logName, 'testbranch', 'the event broadcasted branch name is incorrect')
  // })
  //
  // it('should get remote branches correctly', async () => {
  //   await specimen.newBranch('dev')
  //   await specimen.newBranch('features')
  //
  //   let branches = await specimen.getBranchesName()
  //
  //   console.log(branches)
  //
  //   let b = branches.split('0x|x0')
  //
  //   b.splice(-1, 1)
  //
  //   console.log(b)

  // let hash = '0x' + keccak256('testbranch')
  // let headH = await specimen.getHeadH(hash);
  // console.log(headH)

  // let branchName = await specimen.branches(0)
  //
  // assert.equal(branchName, 'testbranch', 'the registered branch name is incorrect')
  // assert.equal(logName, 'testbranch', 'the event broadcasted branch name is incorrect')
  // })
})
