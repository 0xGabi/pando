const sha3 = require('solidity-sha3').default

const { assertRevert } = require('@aragon/test-helpers/assertThrow')

const getBlockNumber = require('@aragon/test-helpers/blockNumber')(web3)

const DAOFactory = artifacts.require('@aragon/os/contracts/factory/DAOFactory')
const EVMScriptRegistryFactory = artifacts.require('@aragon/os/contracts/factory/EVMScriptRegistryFactory')
const ACL = artifacts.require('@aragon/os/contracts/acl/ACL')
const Kernel = artifacts.require('@aragon/os/contracts/kernel/Kernel')
const Repository = artifacts.require('Specimen')
const Branch = artifacts.require('Branch')
// const SpecimenKit = artifacts.require('SpecimenKit')
const TokenManager = artifacts.require('@aragon/apps-token-manager/contracts/TokenManager')
const MiniMeToken = artifacts.require('@aragon/os/contracts/lib/minime/MiniMeToken')

const ANY_ADDR = '0xffffffffffffffffffffffffffffffffffffffff'
const NULL_ADDR = '0x0000000000000000000000000000000000000000'

const hash_1 = '0x11111111111111111111111111111111'
const hash_2 = '0x22222222222222222222222222222222'




const submittedRFCId = receipt => receipt.logs.filter(x => x.event == 'SubmitRFC')[0].args.rfcId

const sortdRFCCommitId = receipt => {
    if (receipt.logs.filter(x => x.event == 'NewCommit')[0]) {
        return receipt.logs.filter(x => x.event == 'NewCommit')[0].args.commitId
    } else {
        return undefined
    }
}



const { RFC_STATUS, RFC_STATE, RFC_SORTING } = require('../helpers')


contract('Branch', accounts => {
    let factory, token, dao, specimen, master

    const root = accounts[0]
    const author = accounts[1]
    const origin = accounts[2]
    const authorized = accounts[3]
    const unauthorized = accounts[4]
    const parents = web3.eth.abi.encodeParameters(['address', 'bytes32', 'address', 'bytes32'], [authorized, hash_1, author, hash_2])

    const parameters = web3.eth.abi.encodeParameters(['address'], [dummy])


    const deploy = async () => {
        // MiniMeToken
        const token = await MiniMeToken.new(NULL_ADDR, NULL_ADDR, 0, 'Native Governance Token', 0, 'NGT', false)
        // DAO
        const receipt_1 = await factory.newDAO(root)
        const dao = await Kernel.at(receipt_1.logs.filter(l => l.event == 'DeployDAO')[0].args.dao)
        const acl = await ACL.at(await dao.acl())
        await acl.createPermission(root, dao.address, await dao.APP_MANAGER_ROLE(), root, { from: root })
        // TokenManager
        const receipt_2 = await dao.newAppInstance('0x0001', (await TokenManager.new()).address, { from: root })
        const tokenManager = await TokenManager.at(receipt_2.logs.filter(l => l.event == 'NewAppProxy')[0].args.proxy)
        await acl.createPermission(root, tokenManager.address, await tokenManager.MINT_ROLE(), root, { from: root })
        await acl.createPermission(root, tokenManager.address, await tokenManager.ISSUE_ROLE(), root, { from: root })
        await acl.createPermission(root, tokenManager.address, await tokenManager.ASSIGN_ROLE(), root, { from: root })
        await acl.createPermission(root, tokenManager.address, await tokenManager.REVOKE_VESTINGS_ROLE(), root, { from: root })
        await acl.createPermission(root, tokenManager.address, await tokenManager.BURN_ROLE(), root, { from: root })
        await token.changeController(tokenManager.address)
        await tokenManager.initialize(token.address, false, 0, false)
        // Specimen
        const receipt_3 = await dao.newAppInstance('0x0002', (await Repository.new()).address, { from: root })
        const specimen = await Repository.at(receipt_3.logs.filter(l => l.event == 'NewAppProxy')[0].args.proxy)
        await acl.createPermission(root, specimen.address, await specimen.CREATE_BRANCH_ROLE(), root, { from: root })
        await acl.createPermission(root, specimen.address, await specimen.FREEZE_BRANCH_ROLE(), root, { from: root })
        await acl.createPermission(root, specimen.address, await specimen.ISSUE_REWARD_ROLE(), specimen.address, { from: root })
        await specimen.initialize(tokenManager.address)
        await acl.grantPermission(specimen.address, dao.address, await dao.APP_MANAGER_ROLE(), { from: root })
        await acl.grantPermission(specimen.address, tokenManager.address, await tokenManager.MINT_ROLE(), { from: root })
        // Master branch
        const receipt_4 = await specimen.createBranch('master', { from: root })
        const master = await Branch.at(receipt_4.logs.filter(l => l.event == 'CreateBranch')[0].args.proxy)
        await acl.createPermission(authorized, master.address, await master.SUBMIT_RFC_ROLE(), root, { from: root })
        await acl.createPermission(authorized, master.address, await master.VALUATE_RFC_ROLE(), root, { from: root })
        await acl.createPermission(authorized, master.address, await master.SORT_RFC_ROLE(), root, { from: root })

        return { token, dao, specimen, master }
    }

    before(async () => {
        const kernelBase = await Kernel.new()
        const aclBase = await ACL.new()
        const regFact = await EVMScriptRegistryFactory.new()
        factory = await DAOFactory.new(kernelBase.address, aclBase.address, regFact.address)
    })

    beforeEach(async () => {
        ;({ token, dao, specimen, master } = await deploy())
    })

    context('#initialize', () => {
        it('should set specimen and name correctly', async () => {
            const spec = await master.specimen()
            const name = await master.name()

            assert.equal(spec, specimen.address)
            assert.equal(name, 'master')
        })

        it('should revert on reinitialization', async () => {
            return assertRevert(async () => {
                await master.initialize(specimen.address, 'dev', { from: root })
            })
        })
    })

    context('#submitRFC', () => {
        it("should succeed to submit rfc if address is granted 'SUBMIT_RFC_ROLE'", async () => {
            const rfcId = submittedRFCId(await master.submitRFC('awesomeIpfsHash', 'First commit', parents, { from: authorized }))
            const rfc = await master.getRFC(rfcId)

            assert.equal(rfc.origin, authorized)
            assert.equal(rfc.block, 0)
            assert.equal(rfc.tree, 'awesomeIpfsHash')
            assert.equal(rfc.message, 'First commit')
            assert.equal(rfc.parents, parents)
            assert.equal(rfc.value, 0)
            assert.equal(rfc.state, RFC_STATE.PENDING)
            assert.equal(rfc.status, RFC_STATUS.OPEN)
        })

        it("should fail to submit rfc if address is not granted 'SUBMIT_RFC_ROLE'", async () => {
            return assertRevert(async () => {
                await master.submitRFC('awesomeIpfsHash', 'First commit', parents, { from: unauthorized })
            })
        })
    })

    context('#valuateRFC', () => {
        let rfcId

        beforeEach(async () => {
            const acl = await ACL.at(await dao.acl())
            await acl.grantPermission(ANY_ADDR, master.address, await master.SUBMIT_RFC_ROLE(), { from: root })
            rfcId = submittedRFCId(await master.submitRFC('awesomeIpfsHash', 'First commit', parents, { from: origin }))
        })

        it('should succeed to valuate rfc if rfc is open and value is zero and address is origin', async () => {
            await master.valuateRFC(rfcId, 0, { from: origin })
            const rfc = await master.getRFC(rfcId)

            assert.equal(rfc.state, RFC_STATE.VALUATED)
            assert.equal(rfc.value, 0)
        })

        it("should succeed to valuate rfc if rfc is open and address is granted 'VALUATE_RFC_ROLE' even if value is not zero ", async () => {
            await master.valuateRFC(rfcId, 50, { from: authorized })
            const rfc = await master.getRFC(rfcId)

            assert.equal(rfc.state, RFC_STATE.VALUATED)
            assert.equal(rfc.value, 50)
        })

        it("should fail to valuate rfc if value is not zero and address is not granted 'VALUATE_RFC_ROLE' even if rfc is open", async () => {
            return assertRevert(async () => {
                await master.valuateRFC(rfcId, 50, { from: unauthorized })
            })
        })

        it("should fail to valuate rfc if value is not zero and address is not granted 'VALUATE_RFC_ROLE' even if address is origin", async () => {
            return assertRevert(async () => {
                await master.valuateRFC(rfcId, 50, { from: origin })
            })
        })

        it('should fail to valuate rfc if rfc is not open even if value is zero and address is origin', async () => {
            await master.valuateRFC(rfcId, 0, { from: authorized })
            await master.sortRFC(rfcId, RFC_SORTING.MERGE, { from: authorized })

            return assertRevert(async () => {
                await master.valuateRFC(rfcId, 0, { from: origin })
            })
        })

        it("should fail to valuate rfc if rfc is not open even if address is granted 'VALUATE_RFC_ROLE'", async () => {
            await master.valuateRFC(rfcId, 0, { from: authorized })
            await master.sortRFC(rfcId, RFC_SORTING.MERGE, { from: authorized })

            return assertRevert(async () => {
                await master.valuateRFC(rfcId, 50, { from: authorized })
            })
        })
    })

    context('#sortRFC', () => {
        let rfcId

        beforeEach(async () => {
            const acl = await ACL.at(await dao.acl())
            await acl.grantPermission(ANY_ADDR, master.address, await master.SUBMIT_RFC_ROLE(), { from: root })
            rfcId = submittedRFCId(await master.submitRFC('awesomeIpfsHash', 'First commit', parents, { from: origin }))
        })

        context('Merge', () => {
            it('should update head if merge succeeds', async () => {
                await master.valuateRFC(rfcId, 50, { from: authorized })
                await master.sortRFC(rfcId, RFC_SORTING.MERGE, { from: authorized })

                const hash = web3.utils.soliditySha3(
                    { t: 'address', v: origin },
                    { t: 'uint256', v: (await getBlockNumber()) - 1 },
                    { t: 'string', v: 'awesomeIpfsHash' },
                    { t: 'string', v: 'First commit' },
                    { t: 'bytes', v: parents },
                    { t: 'uint256', v: 50 }
                )
                const head = await master.getHead()

                assert.equal(await master.head(), hash)
                assert.equal(head.origin, origin)
                assert.equal(head.block, (await getBlockNumber()) - 1)
                assert.equal(head.tree, 'awesomeIpfsHash')
                assert.equal(head.message, 'First commit')
                assert.equal(head.parents, parents)
                assert.equal(head.value, 50)
            })

            it("should succeed to merge rfc if rfc is open and rfc is valuated and address is granted 'HANDLE_RFC_ROLE'", async () => {
                await master.valuateRFC(rfcId, 50, { from: authorized })
                await master.sortRFC(rfcId, RFC_SORTING.MERGE, { from: authorized })

                const rfc = await master.getRFC(rfcId)

                assert.equal(rfc.state, RFC_STATE.SORTED)
                assert.equal(rfc.status, RFC_STATUS.MERGED)
            })

            it("should fail to merge rfc if address is not granted 'HANDLE_RFC_ROLE' even if rfc is open and valuated", async () => {
                await master.valuateRFC(rfcId, 50, { from: authorized })
                return assertRevert(async () => {
                    await master.sortRFC(rfcId, RFC_SORTING.MERGE, { from: unauthorized })
                })
            })

            it("should fail to merge rfc if rfc is not open even if address is granted 'HANDLE_RFC_ROLE'", async () => {
                await master.valuateRFC(rfcId, 50, { from: authorized })
                await master.sortRFC(rfcId, RFC_SORTING.MERGE, { from: authorized })
                // rfc is already merged and thus not open anymore
                return assertRevert(async () => {
                    await master.sortRFC(rfcId, RFC_SORTING.MERGE, { from: authorized })
                })
            })

            it("should fail to merge rfc if rfc is not valuated even if rfc is open and address is granted 'HANDLE_RFC_ROLE'", async () => {
                return assertRevert(async () => {
                    await master.sortRFC(rfcId, RFC_SORTING.MERGE, { from: authorized })
                })
            })
        })

        context('Reject', () => {
            it("should succeed to reject rfc if rfc is open and address is granted 'HANDLE_RFC_ROLE'", async () => {
                await master.sortRFC(rfcId, RFC_SORTING.REJECT, { from: authorized })

                const rfc = await master.getRFC(rfcId)

                assert.equal(rfc.state, RFC_STATE.SORTED)
                assert.equal(rfc.status, RFC_STATUS.REJECTED)
            })

            it("should fail to reject rfc if address is not granted 'HANDLE_RFC_ROLE' even if rfc is open", async () => {
                return assertRevert(async () => {
                    await master.sortRFC(rfcId, RFC_SORTING.REJECT, { from: unauthorized })
                })
            })

            it("should fail to reject rfc if rfc is not open even if address is granted 'HANDLE_RFC_ROLE'", async () => {
                await master.sortRFC(rfcId, RFC_SORTING.REJECT, { from: authorized })
                // rfc is already rejected and thus not open anymore
                return assertRevert(async () => {
                    await master.sortRFC(rfcId, RFC_SORTING.REJECT, { from: authorized })
                })
            })
        })
    })
})
